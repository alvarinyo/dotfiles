#!/bin/bash

# ---
# Script: aiask
# Description: Query a local Ollama model from the command line, with prompt templates.
#
# Usage:
#   aiask "<prompt>" [--model=<model_name>]
#   aiask --tldr "<prompt>" [--model=<model_name>]
#   aiask --sh "<prompt>" [--model=<model_name>]
#   aiask --file <filepath> "<prompt>" [--model=<model_name>]
#   aiask --file <filepath> --file-line-range <start,end> "<prompt>" [--model=<model_name>]
#   cat file.txt | aiask --file - "<prompt>" [--model=<model_name>]
# ---

# --- 1. Configuration ---
# DEFAULT_MODEL="phi3:mini"
DEFAULT_MODEL="codellama:7b-instruct"

# --- 2. Argument Parsing ---
# Manual parsing to handle options flexibly (supports options before or after prompt)

model="$DEFAULT_MODEL"
prompt_mode="" # This will store "tldr" or "sh"
prompt_parts=()
file_path=""
file_line_range=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      echo "Usage: aiask [OPTIONS] \"<prompt>\""
      echo ""
      echo "Options:"
      echo "  --tldr                      Applies a 'short answer' prompt template."
      echo "  --sh                        Applies a 'bash command only' prompt template."
      echo "  --file FILE                 Include file contents in the prompt for analysis."
      echo "                              Use '-' to read from STDIN."
      echo "  --file-line-range START,END Extract only lines START to END from the file (requires --file)."
      echo "  -m, --model MODEL           Specify the Ollama model (default: '$DEFAULT_MODEL')."
      echo "  -h, --help                  Show this help message."
      echo ""
      echo "Examples:"
      echo "  aiask \"Why is the sky blue?\""
      echo "  aiask --tldr \"Explain quantum physics\""
      echo "  aiask --sh \"list all .txt files\""
      echo "  aiask --sh \"find large files\" -m codellama:7b-instruct"
      echo "  aiask -m phi3:mini \"What is recursion?\""
      echo "  aiask --file script.sh \"What does this script do?\""
      echo "  aiask --file config.json \"Explain this configuration\""
      echo "  aiask --file large_file.log --file-line-range 100,200 \"Analyze these log entries\""
      echo "  cat error.log | aiask --file - \"What caused this error?\""
      echo "  git diff | aiask --file - --file-line-range 1,50 \"Review these changes\""
      exit 0
      ;;
    --tldr)
      if [[ -n "$prompt_mode" ]]; then
        echo "Error: Cannot use --tldr and --sh at the same time." >&2
        exit 1
      fi
      prompt_mode="tldr"
      shift
      ;;
    --sh)
      if [[ -n "$prompt_mode" ]]; then
        echo "Error: Cannot use --tldr and --sh at the same time." >&2
        exit 1
      fi
      prompt_mode="sh"
      shift
      ;;
    -m|--model)
      if [[ -z "$2" ]]; then
        echo "Error: --model requires an argument." >&2
        exit 1
      fi
      model="$2"
      shift 2
      ;;
    --file)
      if [[ -z "$2" ]]; then
        echo "Error: --file requires an argument." >&2
        exit 1
      fi
      file_path="$2"
      shift 2
      ;;
    --file-line-range)
      if [[ -z "$2" ]]; then
        echo "Error: --file-line-range requires an argument." >&2
        exit 1
      fi
      file_line_range="$2"
      shift 2
      ;;
    -*)
      echo "Error: Unknown option '$1'" >&2
      echo "Use --help for usage information." >&2
      exit 1
      ;;
    *)
      # Anything else is part of the prompt
      prompt_parts+=("$1")
      shift
      ;;
  esac
done

# Join all prompt parts into a single string
raw_prompt="${prompt_parts[*]}"

# --- 3. Validation Checks (Basic) ---

# Check if file exists and is readable (skip check for stdin)
if [[ -n "$file_path" && "$file_path" != "-" ]]; then
  if [[ ! -f "$file_path" ]]; then
    echo "Error: File '$file_path' does not exist." >&2
    exit 1
  fi
  if [[ ! -r "$file_path" ]]; then
    echo "Error: File '$file_path' is not readable." >&2
    exit 1
  fi
fi

# Validate file-line-range argument
if [[ -n "$file_line_range" ]]; then
  if [[ -z "$file_path" ]]; then
    echo "Error: --file-line-range requires --file to be specified." >&2
    exit 1
  fi

  # Parse and validate the range format (should be "start,end")
  if [[ ! "$file_line_range" =~ ^[0-9]+,[0-9]+$ ]]; then
    echo "Error: --file-line-range must be in format 'START,END' (e.g., '100,200')." >&2
    exit 1
  fi

  start_line="${file_line_range%,*}"
  end_line="${file_line_range#*,}"

  if [[ "$start_line" -lt 1 ]]; then
    echo "Error: Start line must be >= 1." >&2
    exit 1
  fi

  if [[ "$end_line" -lt "$start_line" ]]; then
    echo "Error: End line must be >= start line." >&2
    exit 1
  fi
fi

# Check for 'curl'
if ! command -v curl &> /dev/null; then
  echo "Error: 'curl' is not installed. Please install it." >&2
  exit 1
fi

# Check for 'jq'
if ! command -v jq &> /dev/null; then
  echo "Error: 'jq' is not installed. Please install it." >&2
  exit 1
fi

# Check for prompt
if [[ -z "$raw_prompt" ]]; then
  echo "Error: No prompt provided." >&2
  echo "Usage: aiask [flag] \"<prompt>\" [--model=<model_name>]" >&2
  exit 1
fi

# Check if Ollama server is running
if ! curl -s "http://localhost:11434" > /dev/null; then
  echo "Error: Ollama server not responding at http://localhost:11434" >&2
  echo "Please ensure Ollama is installed and running." >&2
  exit 1
fi

# --- 4. Build Final Prompt ---

final_prompt=""

# If a file is provided, read its contents and include them in the prompt
file_contents=""
if [[ -n "$file_path" ]]; then
  if [[ "$file_path" == "-" ]]; then
    # Read from STDIN
    if [[ -n "$file_line_range" ]]; then
      # Extract only the specified line range from stdin
      file_contents=$(sed -n "${start_line},${end_line}p")
      file_context="Here is the content from STDIN (lines $start_line to $end_line):

\`\`\`
$file_contents
\`\`\`

"
    else
      # Read all of stdin
      file_contents=$(cat)
      file_context="Here is the content from STDIN:

\`\`\`
$file_contents
\`\`\`

"
    fi
  else
    # Read from a file
    if [[ -n "$file_line_range" ]]; then
      # Extract only the specified line range
      file_contents=$(sed -n "${start_line},${end_line}p" "$file_path")
      file_context="Here is the content of the file '$file_path' (lines $start_line to $end_line):

\`\`\`
$file_contents
\`\`\`

"
    else
      # Read the entire file
      file_contents=$(cat "$file_path")
      file_context="Here is the content of the file '$file_path':

\`\`\`
$file_contents
\`\`\`

"
    fi
  fi
fi

case "$prompt_mode" in
  "tldr")
    # This template instructs the model to be concise.
    final_prompt="${file_context}Respond to the following prompt as concisely as possible (one or two sentences): $raw_prompt"
    ;;
  "sh")
    # This template is very specific to get *only* the code.
    final_prompt="${file_context}You are a bash command generator. Your response must be ONLY the raw bash command, nothing else. Task: $raw_prompt"
    ;;
  *)
    # Default behavior: just use the raw prompt
    if [[ -n "$file_path" ]]; then
      final_prompt="${file_context}$raw_prompt"
    else
      final_prompt="$raw_prompt"
    fi
    ;;
esac

# --- 5. Prepare API Call ---

# The local Ollama API endpoint
api_url="http://localhost:11434/api/generate"

# Safely create the JSON payload using jq
json_payload=$(jq -n \
                  --arg model "$model" \
                  --arg prompt "$final_prompt" \
                  '{model: $model, prompt: $prompt, stream: false}')

# --- 6. Make API Call ---

response=$(curl -s \
             -X POST \
             -H "Content-Type: application/json" \
             -d "$json_payload" \
             "$api_url")

# --- 7. Handle Response ---

# Check for an API error (e.g., model not found)
if echo "$response" | jq -e '.error' > /dev/null; then
  echo "Error calling Ollama API:" >&2
  echo "$response" | jq -r '.error' >&2
  exit 1
fi

# Extract the text response
text_response=$(echo "$response" | jq -r '.response // "null"')

if [[ "$text_response" == "null" ]]; then
  echo "Error: Could not parse a valid response from the API." >&2
  echo "Raw Response:" >&2
  echo "$response" >&2
  exit 1
fi

# --- 8. Post-process and Print Final Response ---

# For --sh mode, clean up the response to ensure only the command is output
if [[ "$prompt_mode" == "sh" ]]; then
  # Remove markdown code blocks (```bash, ```, etc.)
  text_response=$(echo "$text_response" | sed -e 's/^```.*$//' -e 's/^```$//')
  # Remove leading/trailing whitespace and take only the first non-empty line
  text_response=$(echo "$text_response" | grep -v '^[[:space:]]*$' | head -n 1 | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
  # Remove surrounding backticks (leading and trailing)
  text_response=$(echo "$text_response" | sed -e 's/^`//' -e 's/`$//')
fi

# Print the final, clean response to standard output
echo "$text_response"
